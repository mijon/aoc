library(tidyverse)

input <- tibble(input = read_lines("../input/04_input.txt"))

extract_numbers <- function(s) {
  str_extract_all(s, "\\d+") |>
    map(as.numeric)
}

parse_numbers <- function(df) {
  df |> separate(input,
                 into = c("card", "winning", "have"),
                 sep = ":|\\|") |>
    mutate(card = parse_number(card),
           winning = extract_numbers(winning),
           have = extract_numbers(have))
}

calc_score <- function(winning, have) {
  intersection_length = length(intersect(winning, have))
  if_else(intersection_length == 0, 0, 2^(intersection_length - 1))
}

part_1 <- function(input) {
  input |>
    parse_numbers() |>
    mutate(
      score = map2_dbl(
        winning, have,
        calc_score)) |>
    pull(score) |>
    sum()
}

# ---- part 2 ----

# for part 2, we identify that there's an anisotropy in the problem. If we start
# at the first card and then generate a list of cards it generates we'll quickly
# get in a mess as new cards generate newer cards. Instead we can start at the
# end, where we know that the possibilities of card generation are limited (the
# structure of the problem tells us that we can only generate cards *later* in
# the stack, and if you start at the end, there are no later cards).
#
# We can associate a number with each card, this number is the sum of all the
# cards generated by it and its children, i.e. 1 + # generated by its children.
# We then just work from the end back to the start (in a single pass with no
# backtracking) to generate the count of all the cards generated.
calc_score_2 <- function(winning, have) {
  length(intersect(winning, have))
}

gen_score_book <- function(input) {
  input |>
    parse_numbers() |>
    mutate(score = map2_dbl(winning, have, calc_score_2)) |>
    mutate(produces = map2(card, score, \(c, s) {c + seq_len(s)}))  |>
    select(card, produces) |>
    mutate(gives_you = 0)
}

solve_score_book <- function(score_book) {
  update_score_book <- function(card, new_gives_you) {
    score_book$gives_you[score_book$card == card] <<- 1 + sum(map_dbl(get_produces(card), get_score_book))
  }
  
  get_score_book <- function(card) {
    score_book$gives_you[score_book$card == card]
  }
  
  get_produces <- function(card) {
    score_book$produces[score_book$card == card] |> first()
  }
  
  walk(nrow(score_book):1, update_score_book) 
  
  score_book|>
    pull(gives_you) |>
    sum()
}

part_2 <- function(input) {
  solve_score_book(gen_score_book(input))
}

# ---- results ----
part_1(input) # 20407
part_2(input) # 23806951
